import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* Free service (with registration) which serves Government Do Not Call data via API \r\n            Search via phone number returns available data, reported name, total complaints
*/
export class DoNotCallComplaints {
    /**
    * Reported Caller Name
    */
    reportedCallerName: string;
    totalNumberOfComplaints: number;
    complaintsByEntity: { [key: string]: number; };
    lastCompaintDate: Date;
    tags: Array<string>;
}

export class Reputation {
    callType: string;
    confidence: number;
    isSpam: boolean;
    lastCompaintDate: Date;
    reportedCallerName: string;
    tags: Array<string>;
}

/**
* Call Report\r\n            PhoneNumber, \r\n            Caller name(optional), \r\n            Call category(optional), \r\n            Comment or tags(free text) (optional), \r\n            Unwanted call  - yes/no(optional),
*/
export class CallReport {
    phoneNumber: string;
    reportedCallerName: string;
    reportedCallerId: string;
    callerType: CallReport.CallerTypeEnum;
    comment: string;
    unwantedCall: boolean;
    callTime: Date;
    reporter: string;
    reporterLoation: ReporterLoation;
}

export namespace CallReport {
    export enum CallerTypeEnum { 
        Unknown = <any> 'Unknown',
        Telemarketing = <any> 'Telemarketing',
        Collection_Agency = <any> 'Collection_Agency',
        Political = <any> 'Political',
        Surveyor = <any> 'Surveyor',
        Prank_Call = <any> 'Prank_Call',
        Fund_Raiser = <any> 'Fund_Raiser',
        Other_Commercial = <any> 'Other_Commercial',
        Scam = <any> 'Scam',
        Pay_Phone = <any> 'Pay_Phone',
        Business = <any> 'Business',
        Reminder_Notification_Call = <any> 'Reminder_Notification_Call',
        Junk_Fax = <any> 'Junk_Fax',
        Fax_Machine = <any> 'Fax_Machine',
        Spam_Text = <any> 'Spam_Text',
        RoboCall = <any> 'RoboCall',
        NotSpam = <any> 'NotSpam',
        Callback = <any> 'Callback',
    }
}
export class ReporterLoation {
    ipAddress: string;
    latitude: number;
    longitude: number;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class ReputationApi {
    protected basePath = 'https://www.callcontrol.com';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set apiKey(key: string) {
        this.authentications.apiKey.apiKey = key;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * &lt;br /&gt;\r\n&lt;b&gt;Report:&lt;/b&gt; report spam calls received to better tune our algorithms based upon spam calls you receive
     * This returns information required to perform basic call blocking behaviors&lt;br /&gt;\r\n            Try with api_key &#39;demo&#39; and phone number 12674070100 (spam) 12061231234 (not spam)
     * @param callReport [FromBody] Call Report\r\n            PhoneNumber, \r\n            Caller name(optional), \r\n            Call category(optional), \r\n            Comment or tags(free text) (optional), \r\n            Unwanted call  - yes/no(optional),
     */
    public reputationReport (callReport: CallReport) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const path = this.basePath + '/api/2015-11-01/Report';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'callReport' is set
        if (!callReport) {
            throw new Error('Missing required parameter callReport when calling reputationReport');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body?: any;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: callReport,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * &lt;br /&gt;\r\n&lt;b&gt;Reputation&lt;/b&gt;\r\n&lt;br /&gt;\r\n            Premium service which returns a reputation informaiton of a phone number via API.
     * This returns information required to perform basic call blocking behaviors&lt;br /&gt;\r\n            Try with api_key &#39;demo&#39; and phone number 12674070100 (spam) 12061231234 (not spam)
     * @param phoneNumber phone number to search
     */
    public reputationReputation (phoneNumber: string) : Promise<{ response: http.ClientResponse; body: Reputation;  }> {
        const path = this.basePath + '/api/2015-11-01/Reputation/{phoneNumber}'
            .replace('{' + 'phoneNumber' + '}', String(phoneNumber));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is set
        if (!phoneNumber) {
            throw new Error('Missing required parameter phoneNumber when calling reputationReputation');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: Reputation;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class DoNotCallComplaintsApi {
    protected basePath = 'https://www.callcontrol.com';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set apiKey(key: string) {
        this.authentications.apiKey.apiKey = key;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * &lt;br /&gt;\r\n&lt;b&gt;DoNotCallComplaints&lt;/b&gt;\r\n&lt;br /&gt;Free service (with registration), providing community and government complaint lookup by phone number for up to 2,000 queries per month.  Details include number complaint rates from (FTC, FCC, IRS, Indiana Attorney  General) and key entity tag extractions from complaints.
     * This is the main funciton to get data out of the call control reporting system&lt;br /&gt;\r\n            Try with api_key &#39;demo&#39; and phone number 12674070100 (spam) 12061231234 (not spam)
     * @param phoneNumber phone number to search
     */
    public doNotCallComplaintsDoNotCallComplaints (phoneNumber: string) : Promise<{ response: http.ClientResponse; body: DoNotCallComplaints;  }> {
        const path = this.basePath + '/api/2015-11-01/DoNotCallComplaints/{phoneNumber}'
            .replace('{' + 'phoneNumber' + '}', String(phoneNumber));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is set
        if (!phoneNumber) {
            throw new Error('Missing required parameter phoneNumber when calling doNotCallComplaintsDoNotCallComplaints');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: DoNotCallComplaints;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
