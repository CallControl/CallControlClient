import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class CallControlUser {
    "phoneNumber": string;
    "phoneNumbeRegion": string;
    "whiteList": Array<string>;
    "blackList": Array<string>;
    "quietHourList": Array<QuietHour>;
    "useCommunityBlacklist": boolean;
    "breakThroughQhWithMultipleCalls": boolean;
    "whiteListBreaksQh": boolean;
    "blockBehavior": CallControlUser.BlockBehaviorEnum;
    "email": string;
    "age": number;
    "gender": string;
    "salutation": string;
    "firstName": string;
    "middleName": string;
    "lastName": string;
    "suffix": string;
}

export namespace CallControlUser {
    export enum BlockBehaviorEnum { 
        allow = <any> 'allow',
        voiceMail = <any> 'voiceMail',
        block = <any> 'block'
    }
}
/**
* Call Report\r\n            PhoneNumber, \r\n            Caller name(optional), \r\n            Call category(optional), \r\n            Comment or tags(free text) (optional), \r\n            Unwanted call  - yes/no(optional),
*/
export class CallReport {
    "phoneNumber": string;
    "reportedCallerName": string;
    "reportedCallerId": string;
    "callerType": CallReport.CallerTypeEnum;
    "comment": string;
    "unwantedCall": boolean;
    "callTime": Date;
    "reporter": string;
    "ipAddress": string;
    "latitude": number;
    "longitude": number;
}

export namespace CallReport {
    export enum CallerTypeEnum { 
        Unknown = <any> 'Unknown',
        Telemarketing = <any> 'Telemarketing',
        Collection_Agency = <any> 'Collection_Agency',
        Political = <any> 'Political',
        Surveyor = <any> 'Surveyor',
        Prank_Call = <any> 'Prank_Call',
        Fund_Raiser = <any> 'Fund_Raiser',
        Other_Commercial = <any> 'Other_Commercial',
        Scam = <any> 'Scam',
        VOIP = <any> 'VOIP',
        Business = <any> 'Business',
        Reminder_Notification_Call = <any> 'Reminder_Notification_Call',
        Junk_Fax = <any> 'Junk_Fax',
        Fax_Machine = <any> 'Fax_Machine',
        Spam_Text = <any> 'Spam_Text',
        RoboCall = <any> 'RoboCall',
        NotSpam = <any> 'NotSpam',
        Callback = <any> 'Callback'
    }
}
/**
* Free service (with registration) which serves Government Do Not Call data via API \r\n            Search via phone number returns available data, reported name, total complaints
*/
export class Complaints {
    /**
    * Reported Caller Name
    */
    "reportedCallerName": string;
    "totalNumberOfComplaints": number;
    "complaintsByEntity": { [key: string]: number; };
    "lastCompaintDate": Date;
    "tags": Array<string>;
}

export class Object {
}

export class QuietHour {
    "dayOfWeekList": Array<string>;
    "startHourLocal": number;
    "startMinLocal": number;
    "durationMin": number;
    "timeZoneName": string;
}

export class Reputation {
    "callType": string;
    "confidence": number;
    "isSpam": boolean;
    "lastCompaintDate": Date;
    "reportedCallerName": string;
    "tags": Array<string>;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class ComplaintsApi {
    protected basePath = 'https://www.callcontrol.com';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set apiKey(key: string) {
        this.authentications.apiKey.apiKey = key;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Complaints: Free service (with registration), providing community and government complaint lookup by phone number for up to 2,000 queries per month.  Details include number complaint rates from (FTC, FCC, IRS, Indiana Attorney  General) and key entity tag extractions from complaints.
     * This is the main funciton to get data out of the call control reporting system&lt;br /&gt;\r\n            Try with api_key &#39;demo&#39; and phone numbers 18008472911, 13157244022, 17275567300, 18008276655, and 12061231234 (last one not spam)
     * @param phoneNumber phone number to search
     */
    public complaintsComplaints (phoneNumber: string) : Promise<{ response: http.ClientResponse; body: Complaints;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Complaints/{phoneNumber}'
            .replace('{' + 'phoneNumber' + '}', String(phoneNumber));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is set
        if (!phoneNumber) {
            throw new Error('Missing required parameter phoneNumber when calling complaintsComplaints');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Complaints;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class EnterpriseApiApi {
    protected basePath = 'https://www.callcontrol.com';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set apiKey(key: string) {
        this.authentications.apiKey.apiKey = key;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Enterprise  GET: GetBlockList\r\n            Simple Enteprise which returns the current and complete list of numbers that the network is blocking
     * All \r\n            Try with api_key &#39;demo&#39; for the demo block list (which will block 18008472911, 13157244022, 17275567300, 18008276655) but not 12061231234
     * @param cached 
     */
    public enterpriseApiGetBlockList (cached?: boolean) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Enterprise/GetBlockList';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (cached !== undefined) {
            queryParameters['cached'] = cached;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<string>;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Enterprise  GET: GetUser\r\n            Returns the current information from the user
     * 
     * @param phoneNumber 
     */
    public enterpriseApiGetUser (phoneNumber: string) : Promise<{ response: http.ClientResponse; body: CallControlUser;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Enterprise/GetUser/{phoneNumber}'
            .replace('{' + 'phoneNumber' + '}', String(phoneNumber));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is set
        if (!phoneNumber) {
            throw new Error('Missing required parameter phoneNumber when calling enterpriseApiGetUser');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CallControlUser;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Enterprise  GET: ShouldBlock\r\n            Simple Enteprise which returns a call block proceed decision.
     * This returns information required to perform basic call blocking behaviors\r\n            Try with api_key &#39;demo&#39; and phone numbers 18008472911, 13157244022, 17275567300, 18008276655, and 12061231234 (last one not spam)
     * @param phoneNumber phone number to search
     * @param userPhoneNumber (OPTOPNAL) phone number of user to look up block rules
     */
    public enterpriseApiShouldBlock (phoneNumber: string, userPhoneNumber: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Enterprise/ShouldBlock/{phoneNumber}/{userPhoneNumber}'
            .replace('{' + 'phoneNumber' + '}', String(phoneNumber))
            .replace('{' + 'userPhoneNumber' + '}', String(userPhoneNumber));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is set
        if (!phoneNumber) {
            throw new Error('Missing required parameter phoneNumber when calling enterpriseApiShouldBlock');
        }

        // verify required parameter 'userPhoneNumber' is set
        if (!userPhoneNumber) {
            throw new Error('Missing required parameter userPhoneNumber when calling enterpriseApiShouldBlock');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * 
     * @param user 
     */
    public enterpriseApiUpsertUser (user: CallControlUser) : Promise<{ response: http.ClientResponse; body: Object;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Enterprise/UpsertUser';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'user' is set
        if (!user) {
            throw new Error('Missing required parameter user when calling enterpriseApiUpsertUser');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Object;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: user,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class ReputationApi {
    protected basePath = 'https://www.callcontrol.com';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set apiKey(key: string) {
        this.authentications.apiKey.apiKey = key;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Report: report spam calls received to better tune our algorithms based upon spam calls you receive
     * This returns information required to perform basic call blocking behaviors&lt;br /&gt;\r\n            Try with api_key &#39;demo&#39; and phone numbers 18008472911, 13157244022, 17275567300, 18008276655, and 12061231234 (last one not spam)
     * @param callReport [FromBody] Call Report\r\n            PhoneNumber, \r\n            Caller name(optional), \r\n            Call category(optional), \r\n            Comment or tags(free text) (optional), \r\n            Unwanted call  - yes/no(optional),
     */
    public reputationReport (callReport: CallReport) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Report';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'callReport' is set
        if (!callReport) {
            throw new Error('Missing required parameter callReport when calling reputationReport');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: callReport,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Reputation:\r\n            Premium service which returns a reputation informaiton of a phone number via API.
     * This returns information required to perform basic call blocking behaviors&lt;br /&gt;\r\n            Try with api_key &#39;demo&#39; and phone numbers 18008472911, 13157244022, 17275567300, 18008276655, and 12061231234 (last one not spam)
     * @param phoneNumber phone number to search
     */
    public reputationReputation (phoneNumber: string) : Promise<{ response: http.ClientResponse; body: Reputation;  }> {
        const localVarPath = this.basePath + '/api/2015-11-01/Reputation/{phoneNumber}'
            .replace('{' + 'phoneNumber' + '}', String(phoneNumber));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'phoneNumber' is set
        if (!phoneNumber) {
            throw new Error('Missing required parameter phoneNumber when calling reputationReputation');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Reputation;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
